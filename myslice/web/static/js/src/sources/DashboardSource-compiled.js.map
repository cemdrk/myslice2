{"version":3,"sources":["DashboardSource.js"],"names":[],"mappings":";;;;;;AAGA;;;;AACA;;;;AACA;;;;;;AAEA,IAAM,kBAAkB,SAAlB,eAAkB,GAAM;AAC1B,WAAO;AACH,eAAO;AAEH,kBAFG,kBAEI,KAFJ,EAEW;;AAGV,uBAAO,gBAAM,GAAN,CAAU,kBAAV,CAAP;AAGH,aARE;;;AAUH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAS,2BAAQ,cAlBd,EAkB8B;AACjC,mBAAO,2BAAQ,aAnBZ,EAmB2B;;AAE9B;AACA;AACA,uBAvBG,uBAuBS,KAvBT,EAuBgB;AACf,uBAAO,IAAP;AACH;AAzBE,SADJ;;AA+BH,gBAAQ;AAEJ,kBAFI,kBAEG,KAFH,EAEU;AACV,oBAAI,MAAM,OAAN,CAAc,OAAlB,EAA2B;AACvB,2BAAO,gBAAM,GAAN,CAAU,sBAAsB,MAAM,OAAN,CAAc,OAAd,CAAsB,EAA5C,GAAiD,SAA3D,CAAP;AACH;AAEJ,aAPG;;;AASJ;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,uBAnBI,uBAmBQ,KAnBR,EAmBe;AACf,uBAAO,IAAP;AACH;AArBG,SA/BL;;AAwDH,gBAAQ;AACJ;AACA,kBAFI,kBAEG,KAFH,EAEU;AACV,oBAAI,IAAI,QAAR;AACA,oBAAI,MAAM,QAAV,EAAoB,IAAI,QAAJ;AACpB,oBAAI,MAAM,WAAV,EAAuB,IAAI,WAAJ;AACvB,oBAAI,MAAM,SAAV,EAAqB,IAAI,SAAJ;AACrB,uBAAO,gBAAM,IAAN,CAAW,kBAAX,EAA+B;AAC9B,6BAAS,MAAM,KADe;AAE9B,4BAAS,MAAM,IAFe;AAG9B,iCAAa,MAAM,SAHW;AAI9B,kCAAc,CAJgB;AAK9B,2BAAO,MAAM,GALiB;AAM9B,mCAAe,MAAM,WANS;AAO9B,kCAAc,MAAM,UAPU;AAQ9B,gCAAY,MAAM;AARY,iBAA/B,CAAP;AAUH,aAjBG;;;AAmBJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAS,8BAAY,aA3BjB,EA2BgC;AACpC,mBAAO,8BAAY,WA5Bf,EA4B4B;;AAEhC;AACA;AACA,uBAhCI,uBAgCQ,KAhCR,EAgCe;AACf,uBAAO,IAAP;AACH;AAlCG;AAxDL,KAAP;AA6FH,CA9FD,C,CAPA;;;kBAuGe,e","file":"DashboardSource-compiled.js","sourcesContent":["/**\n * Created by amirabradai on 17/10/2016.\n */\nimport axios from 'axios';\nimport actions from '../actions/DashboardActions';\nimport formactions from '../actions/ProjectsFormActions';\n\nconst DashboardSource = () => {\n    return {\n        fetch: {\n\n            remote(state) {\n\n\n                return axios.get('/api/v1/projects');\n\n\n            },\n\n            // this function checks in our local cache first\n            // if the value is present it'll use that instead (optional).\n            // local(state) {\n            //     return state.authorities ? state.authorities : null;\n            // },\n\n            // here we setup some actions to handle our response\n            //loading: actions.loadingResults, // (optional)\n            success: actions.updateProjects, // (required)\n            error: actions.errorProjects, // (required)\n\n            // should fetch has precedence over the value returned by local in determining whether remote should be called\n            // in this particular example if the value is present locally it would return but still fire off the remote request (optional)\n            shouldFetch(state) {\n                return true\n            }\n        },\n\n\n\n        slices: {\n\n            remote(state) {\n                if (state.current.project) {\n                    return axios.get('/api/v1/projects/' + state.current.project.id + '/slices');\n                }\n\n            },\n\n            // local(state) {\n            //     return state.authorities ? state.authorities : null;\n            // },\n\n            // here we setup some actions to handle our response\n            //loading: actions.loadingResults, // (optional)\n\n\n            // should fetch has precedence over the value returned by local in determining whether remote should be called\n            // in this particular example if the value is present locally it would return but still fire off the remote request (optional)\n            shouldFetch(state) {\n                return true\n            }\n        },\n\n\n        submit: {\n            // remotely fetch something (required)\n            remote(state) {\n                var v = 'public';\n                if (state.v_public) v = 'public';\n                if (state.v_protected) v = 'protected';\n                if (state.v_private) v = 'private';\n                return axios.post('/api/v1/projects', {\n                        'label': state.label,\n                        'name':  state.name,\n                        'authority': state.authority,\n                        'visibility': v,\n                        'url': state.url,\n                        'description': state.description,\n                        'start_date': state.start_date,\n                        'end_date': state.end_date,\n                    });\n            },\n\n            // this function checks in our local cache first\n            // if the value is present it'll use that instead (optional).\n            // local(state) {\n            //     return state.authorities ? state.authorities : null;\n            // },\n\n            // here we setup some actions to handle our response\n            //loading: actions.loading, // (optional)\n            success: formactions.submitSuccess, // (required)\n            error: formactions.submitError, // (required)\n\n            // should fetch has precedence over the value returned by local in determining whether remote should be called\n            // in this particular example if the value is present locally it would return but still fire off the remote request (optional)\n            shouldFetch(state) {\n                return true\n            }\n        }\n    }\n};\n\nexport default DashboardSource;\n\n"]}